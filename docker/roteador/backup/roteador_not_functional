import threading
import time
import socket
import json
import os 
import subprocess
from dijkstra import dijkstra
from script_teste.roteador import Roteador

ROTEADOR_ID = os.getenv("ROTEADOR_ID")
ENDERECO_IP = os.getenv("ENDERECO_IP")
VIZINHOS = json.loads(os.getenv("VIZINHOS"))

PORTA_LSA = 5000

def atualizar_rota(tabela):
    for destino, prox_salto in tabela.items():
        
        destino = f"172.21.{int(destino.split('r')[-1]) - 1}.0/24"
        prox_salto = f"172.21.{int(prox_salto.split('r')[-1]) - 1}.2"
        comando = f"ip route add {destino} via {prox_salto}"
        print(f"[{ROTEADOR_ID}] Executando: {comando}")
        try:
            # Remover rota existente para evitar erros
            subprocess.run(f"ip route del {destino} || true", shell=True)
            result = subprocess.run(comando, shell=True, capture_output=True, text=True)  # Executa o comando no sistema operacional
            
            if result.returncode != 0:
                print(f"[{ROTEADOR_ID}] Erro ao executar comando: {result.stderr.strip()}")
                if "RTNETLINK answers: File exists" in result.stderr:
                    subprocess.run(f"ip route replace {destino} via {prox_salto}", shell=True)
            else:
                print(f"[{ROTEADOR_ID}] Comando executado com sucesso: {result.stdout.strip()}")
                
        except Exception as e:
            print(f"[{ROTEADOR_ID}] Erro ao adicionar rota: {e}")
            
def atualizar_tabela(lsdb,inativos):
    while True:
        tabela = {}
        if lsdb:
            tabela = dijkstra(ROTEADOR_ID, lsdb,inativos=inativos)
        
        if tabela:
            print(f"[{ROTEADOR_ID}] Nova tabela de rotas:")
            for destino, prox_salto in tabela.items():
                print(f"  {destino} → via {prox_salto}")
            
            atualizar_rota(tabela)
        else:
            print(f"[{ROTEADOR_ID}] Nenhuma rota encontrada.")
            
        time.sleep(5)

def enviar_lsa():
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    seq = 0
    while True:
        seq += 1
        lsa = {
            "id": ROTEADOR_ID,
            "ip": ENDERECO_IP,
            "vizinhos": {
                viz: {"ip": ip, "custo": custo} for viz, (ip, custo) in VIZINHOS.items()
            },
            "seq": seq
        }
        print(f"[{ROTEADOR_ID}] Enviando LSA para: {list(VIZINHOS.keys())}")
        
        mensagem = json.dumps(lsa).encode()
        for viz, (ip, _) in VIZINHOS.items():
            sock.sendto(mensagem, (ip, PORTA_LSA))
        
        time.sleep(5)

def receber_lsa(lsdb):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(("0.0.0.0", PORTA_LSA))
    while True:
        dados, addr = sock.recvfrom(4096)
        sender_ip = addr[0]
        lsa = json.loads(dados.decode())
        origem = lsa["id"]
        
        if origem not in lsdb or lsa["seq"] > lsdb[origem]["seq"]:
            lsdb[origem] = lsa
            for viz, (ip, _) in VIZINHOS.items():
                if ip != sender_ip:
                    sock.sendto(dados, (ip, PORTA_LSA))
                    print(f"[{ROTEADOR_ID}] Encaminhando LSA para {viz} ({ip})")

def verificaVizinhos(inativos):
    
    while True:
        inativo = []
        if VIZINHOS:
            for roteador in list(VIZINHOS.keys()):
                try:
                    ip = VIZINHOS[roteador][0]
                    resultado = subprocess.run(f"ping -c 1 -W 0.1 {ip}", shell=True, check=True, text=True, capture_output=True)
                    if resultado.returncode == 0:
                        print(f"[{ROTEADOR_ID}] Roteador {roteador} está acessível.")
                    else:
                        inativo.append(roteador) if roteador not in inativo else None
                        print(f"[{ROTEADOR_ID}] Roteador {roteador} não está acessível.")
                except:
                    inativo.append(roteador) if roteador not in inativo else None
                    print(f"[{ROTEADOR_ID}] Roteador {roteador} não está acessível.")

            inativos = inativo.copy()
            print(f"[{ROTEADOR_ID}] Vizinhos inativos: {inativos}")
            
            for roteador in inativo:
                print(f"[{ROTEADOR_ID}] Removendo {roteador} da LSDB.")
                # lsdb.pop(roteador, None)
                
                roteador_id = roteador.split("r")[-1]
                
                destino = f"172.21.{int(roteador_id) - 1}.0/24"
                comando = f"ip route del {destino}"
                
                try:
                    print(f"[{ROTEADOR_ID}] Executando: {comando}")
                    subprocess.run(comando, shell=True, check=True)
                except subprocess.CalledProcessError as e:
                    print(f"[{ROTEADOR_ID}] Erro ao remover rota: {e}")

        else:
            print(f"[{ROTEADOR_ID}] LSDB vazia.")

def iniciar_threads():
    lsdb = {}
    inativos = []
    
    t1 = threading.Thread(target=enviar_lsa)
    t2 = threading.Thread(target=receber_lsa, args=(lsdb,))
    t3 = threading.Thread(target=atualizar_tabela, args=(lsdb,inativos,))
    t4 = threading.Thread(target=verificaVizinhos, args=(inativos,))
    
    for t in [t1, t2, t3, t4]:
        t.daemon = True
        t.start()

    threading.Event().wait()

if __name__ == "__main__":
    print(f"[{ROTEADOR_ID}] Iniciado com vizinhos: {VIZINHOS}")
    iniciar_threads()
